# 重构目的

- 于公司：有利于项目的长远维护
- 于员工：面对好的代码和架构心情舒畅


# 重构达到的效果

主要提升了项目以下特性

- 可维护性
- 健壮性
- 可扩展性


## 可维护性

我们是如何提升可维护性的呢？

- ### 1、新技术和框架
  
  由于上个项目我们已经使用了Vuetify组件库开发了网信办的项目，也体会到了Vuetify的一些优秀的地方，当然也有一些不足，本项目由于对UI这一块有严格的要求，而Vuetify的部分组件的UI显得不太适合，比如日期时间选择器和表格组件，显然ElementUI更适合。于是我们在项目中同时引入了Vuetify和ElementUI，取各自的长处，当然以Vuetify为主。同时由于二者都可以按需加载，所以对最终的打包文件影响不大，在保证性能的同时极大扩展了应对不同场景和UI的灵活性。

  新的技术和框架往往会伴随着更好的生态，包括人力资源上，对求职者有更大的吸引力，这样才会有源源不断的开发者愿意为项目做持续的维护。

- ### 2、约定风格简化代码
  
  所有组员的代码都会有一些基本的代码风格约定，此外还有风格之外的代码优化，尽量提升可读性，包括：
  - Eslint 对风格上的强制约束
  - 变量命名和组件Prop命令保证尽可能高的可读性
  - 基于 Vuetify 的 CSS Utilities 避免各种自定义类名
  
  以上约束可以尽量保证代码的统一，让后续的维护人员能够更好的阅读理解和开发。

- ### 3、复用组件

  老版（包括网信办）的最大问题是过于重复，相同功能的组件写了无数次，这样会导致维护的时候要改一个东西就得改动很多处，改得越多，不确定性也就越多了，因此我们的重点是要复用相同逻辑的组件。

  比如每个板块的结构都是 左侧分类 + 右侧（顶部筛选栏 + 下面的数据列表），左侧分类传入不同的参数即可，右侧顶部筛选栏每个板块是不一样的，我们就把每种筛选独立成组件，然后再自由组装成各自板块的筛选栏即可。右侧底部的数据列表也不尽相同，有表格，也有数据列，也有图片列表（报刊）的，提升一下逻辑就是，不同板块可能存在不同的数据视图，那么我们可以建立前面的多个数据视图，每个板块引用自己需要的即可。

  复用组件最明显的好处就是，不管是开发还是维护，不用重复去改逻辑，只需要把精力放在公共组件上维护好即可，其次再后续改动的时候，也不至于搜索一个关键字就出来一大堆，能够快速定位到出问题的地方。

- ### 4、协作规范
  
  从项目协作来说，借助 `git cz` 工具，我们尽量规范了提交信息的格式，也定义了一些规则：

  - 有JIRA号的，尽量加上JIRA号（写到scope change中）
  - 描述清楚本次提交做了什么，不要简单地复制JIRA描述
  - 只有feat和fix的提交会记录到changelog中，所以应该判断自己的提交为哪种类型，是否应该加入changlog
  - 记录到changelog中的提交尽量跟业务相关，如代码架构上的优化就不要提交为这两种类型了
  - break change 也会记录到changelog中，一般不要勾选这个
  - 尽量少用优化类的字眼，把描述细化到具体做了什么事


## 健壮性

没有不出Bug的程序，Bug 是避免不了的，我们能做的就是尽量减少Bug，最大限度的适应多种未知情况。其中上面提到的复用是很重要的一个点，能够大大降低因为逻辑分散带来的不确定性，专注维护公共模块必然会让我们减少Bug出现的机率。当然也包括简化代码和逻辑，框架的正确选择，这些都会让我们最终面对的代码足够清晰和聚焦。

## 可扩展性

我们在提取组件的时候会遵循如下原则：

- 尽量在使用的时候更方便
- 尽量适配各自情况

简而言之就是简单+强大，换句话说就是使用简单+扩展性强，那么我们是如何做的呢？

- ###  1、界定组件职责

  首先要清楚这个组件是做什么用的，需要接收什么，需要对外输出什么，需要完成什么事，这是一个业务组件还是功能组件，大部分使用场景是什么，会有哪些特殊情况。这些都会影响到我们组件的一个开发结果和效果。当然也不是一开始就能做到那么完善，随着场景越来越丰富，这将会是一个不断完善和优化的过程。

  拿取稿那排操作按钮来说，我们提取到了一个公共组件`DraftOperation.vue` 中，下面是稿件列表页需要的功能

  ![](./assets/do.png)

  但是稿件详情页的操作却是这样的

  ![](./assets/dd.png)

  那么这个时候我们想共用这个组件，应该如何设计呢？在里面去 `v-if` 吗？如果这个按钮顺序也不固定呢？

  我们的做法是，定义一个 `scope` 属性

  ```js
    scopes: {
        type: Array,
        default: () => ['td', 'ap', 'co', 'pr', 'ep']
    }
  ```

  它代表着我要渲染的操作按钮的 `key` 的集合，然后我会过滤出我需要渲染的按钮，由于是数组，也能反应出它的按钮排序，只需一个计算属性即可：

  ```js
  {
    data() {
      return {
        btns: [ // 完整按钮列表
            {
                name: '取稿',
                key: 'td',
                action: 'showTakeDraft'
            },
            {
                name: '添加到个人素材',
                key: 'ap',
                action: 'addToPersonal'
            }
            ....
        ]
      }
    },
    computed: {
        // 实际要渲染的按钮
        formatBtns() {
            return this.scopes.reduce((result, key) => {
                const item = this.btns.find(btn => btn.key === key);
                if (item) result.push(item);
                return result;
            }, []);
        }
    }
  }
  ```

  > 在此吐槽一下 ElementUI的表格组件，无法轻松地定制有哪些列以及列的顺序。

  这样在以后有新的功能按钮或者要调整不同地方引用的按钮数量和顺序的时候就会非常方便了。

- ### 2、组件层级

  我们拿筛选栏举例，在一个板块里面，我们会有一个筛选栏的组件 `FilterBar.vue` 如下

  ```js
  <template>
      <ProgramFilter></ProgramFilter> // 栏目筛选
      <KeywordFilter></KeywordFilter> // 关键字搜索
      <SubjectFilter></SubjectFilter> // 主题筛选
      <DateFilter></DateFilter> // 日期时间筛选
  </template>
  ```

  可以看到里面引用了不同类别的筛选组件，因为在另外一个板块里面，可能只要日期筛选，那么他的 `FilterBar.vue` 就变成了

   ```js
  <template>
      <DateFilter></DateFilter> // 日期时间筛选
  </template>
  ```

  因此这一块我们实际上是自由组装各种类型的筛选成为某个板块自己的筛选逻辑。接着我们看看其中的栏目筛选 `ProgramFilter` 是什么样的

  ```js
  <template>
      <BasicFilter></BasicFilter> // 基础筛选组件
  </template>
  ```

  这里我们引入了 `BasicFilter`，为什么不直接写，而要引用这个呢？因为即便是各种筛选，他们中的部分筛选是有相同的视图的，而相同的视图实际上也是比较复杂的，如果要写到每个筛选模块中，显然是很重复的，因此我们把这一块给独立成了 BasicFilter，专门用来实现这种视图的筛选，后续如果有新的类型的筛选，我们也可以很快速地实现了。


  如上就是所谓的组件分级，每一级都应该做好自己的事，这样就能在不用的层级上去扩展出上一级的组件，减少了重复UI和逻辑，尽量做到了复用。

- ### 3、不光是组件

  在 Vue.js 中除了组件，还有混入之类的共用方式。

  拿右下方的数据表格来说，虽然他们的视图不一样，有表格，也有微博这样的列表形式，但是他们有一些相同的逻辑，比如选择稿件、跳转详情页等，这些逻辑其实就可以被提到一个Mixin中，在所有的数据视图中都可以直接引入使用，这样就避免了相同逻辑的重复。

  再拿URL记忆组件说一下，这个组件是在网信办重构中写的，自身也经历了一次重构，最开始的时候我们是把要记忆的参数和参数修改之后要做的逻辑都写到了组件中，很不灵活。后面我们思考到，URL记忆应该是以一个插件的形式存在，有它无它都不会影响到我本身的逻辑，所以我们就将其变成可一个Mixin

  1、在需要进行记忆的组件中引入 `UrlRememberMixin`

  ```js
  import UrlRememberMixin from '@/mixins/urlRemember';
  export default {
    mixins: [UrlRememberMixin]
    ...
  }
  ```
  2、在页面 data 中加入 `urlRemember` 字段，格式为

  ```js
  export default {
    data() {
        return {
          urlRemember: {
            key: 'params',
            rules: ['mediaType', 'startTime', 'endTime', 'keywords', 'type']
          }
        }
    }
  }
  ```

  这样设计的好处是，我可以通过配置很方便地决定哪些参数需要被记忆到URL中，去掉他就不会有记忆，但是程序一样可以正确运行。真正做到了自由可配置，对扩展性来说无疑是有帮助的。


# 重构路径

- ## 1、技术框架选型

  通过页面的UI和项目的浏览器兼容要求，选择最适合的UI框架。
- ### 2、主题配置
  
  每个项目的UI设计要求不一样，在使用同一个组件库开发的时候就需要先设置一些统一的全局样式变量，比如主题颜色、文本框和按钮高度，ElementUI和Vuetify都提供了主题主题变量的配置功能。

- ## 3、核心模板开发

  浏览整个网站的页面组成，分析公共模块，大致得出重构的分工进程。以本项目为例，整体布局是左右三栏，每个板块的页面结构基本上都是一样的，然后我们其中一人先开发完成其中一个完整的板块样板，开发过程中不断优化和提取公共组件，

  待样板板块开发完成之后，再接着开发其它板块页面，同时进一步优化和抽取复用组件。

- ## 4、独立板块开发

  在核心板块开发的同时，组内其它成员可以开发独立页面和功能组件（比如分页组件、消息组件、取稿功能、数字报刊详情页）这些页面和组件不影响整体的架构，所以是可以同时进行，互不干扰的。

- ## 5、审查代码和功能

  开发过程中应该不断地和原项目对照UI和功能逻辑，发现有不一致的地方需要修正，同时小组长应该对团队代码进行审查。


# 遇到的问题

- ## 1、对业务不了解

  这个是在我们重构途中遇到的主要问题，对于一些复杂的业务，比如取稿，页面看上去就一个弹框，但是里面涉及到了各种逻辑，由于我们本身没有做过这个项目，所以理解起来就比较吃力了。

  不过我们的方法是，先不去了解清楚逻辑，而是根据页面和请求把大致的组件开发出来，接着再深入到其中的某个细节，仔细查看老版代码去修改和完善，比如直接编辑这个按钮，里面涉及到了很多的参数拼接，但是如果一开始就陷入到细节的，就会影响进度和效果。


- ## 2、佛性网络

  由于本项目是需要通过VPN访问的，而这个VPN又极其不稳定，看天敲代码，非常影响效率。这种情况怎么办呢？理论上应该是后端部署一个本地的环境，但是由于公司没有这种条件，所以我们开发了一个抓取URL到本地进行模拟的工具，主要针对这种独立页面，没有太多交互逻辑的，比如诗佳开发数字报刊详情页的时候就用了这个工具抓取数据和Mock数据。（https://git.trscd.com.cn/cdtrs/dev/03_super_star/tianMuYun/apicollector）


  ### 使用过程

  > 开始之前先从 `master` 切出一个分支， 因为master只包含功能，具体的项目收集到的接口请切到其它业务分支里面去做。

  - 1、先收集接口
  - 2、启动mock服务器
  - 3、设置开发代理

  ### 收集接口

  1、启动收集服务

  ```bash
  npm run server
  ```

  2、将 `RecoedAPI` 中的内容复制到要收集接口的网站 `F12 Console` 中，然后点击各种链接触发请求。

  > 由于需要在网页加载完成之后才能将脚本注入，但是之前已经发送了部分请求，这一部分请求是不能自动监控到的，这个时候需要在F12的 Network 中右键选中其中一个请求，然后选择 `copy as fetch` 然后在 Console 中粘贴，回车执行即可。

  ### Mock服务

  启动Mock服务器

  ```bash
  npm run mock
  ```



